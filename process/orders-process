#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

from os import unlink, symlink
import sys
import os
import subprocess, shlex
from re import compile, IGNORECASE
from string import split, join, strip
from sys import exit
from time import sleep, time, ctime
from syslog import openlog, closelog, syslog

from epasswd import EPasswd
import eorders
from eorders import get_eressea_dir, split_filename, lock_file, unlock_file, EConfig


messages = {
"subject-de": "Befehle angekommen",
"subject-en": "orders received",

"validate-en": "Validating",
"validate-de": "Verarbeite",

"faction-en": "Faction",
"faction-de": "Partei",

"unknown-de": "WARNUNG: Die Partei ist nicht bekannt, oder das Passwort falsch!",
"unknown-en": "WARNING: This faction is unknown, or the password is incorrect!",

"warning-de": "Warnung",
"warning-en": "Warning",

"error-de": "Fehler",
"error-en": "Error",

"nocheck-de": "Kein Syntaxchecker installiert. Der Zug wird akzeptiert, wurde aber nicht überprüft",
"nocheck-en": "Syntax checker is broken. Your turn was accepted, but could not be verified.",
}

game = int(sys.argv[1])
maxlines = 25

rootdir=get_eressea_dir()

gamedir = os.path.join(rootdir, "game-%d" % (game, ))
serverdir = os.path.join(rootdir, "server")
frommail = None
gamename = None
checker = None
muttrc=os.path.join(rootdir, "etc/muttrc")

inifile = os.path.join(gamedir, 'eressea.ini')
if not os.path.exists(inifile):
    print "no such file: " . inifile
    sys.exit(1)
else:
    config = EConfig(inifile)
    frommail = config.get('game', 'email', abort=1)
    gamename = config.get('game', 'name', abort=1)
    sender = config.get('game', 'sender', default="%s Server <%s>" % (gamename, frommail))
    frommail = config.get('lua', 'install', abort=1)
    checker = config.get('game', 'checker', default=None)

queue_file = os.path.join(gamedir, "orders.queue")
if not os.path.exists(queue_file):
    sys.exit(0)

# regular expression that finds the start of a faction
fact_re = compile("^\s*(eressea|partei|faction)\s+([a-zA-Z0-9]+)\s+\"?([^\"]*)\"?", IGNORECASE)

def check_pwd(filename, email, pw_data):
    results = []
    try:
        file = open(filename, "r")
    except:
        print "could not open file", filename
        return results
    for line in file.readlines():
        mo = fact_re.search(strip(line))
        if mo != None:
            fact_nr = str(mo.group(2))
            fact_pw = str(mo.group(3))
            if pw_data.fac_exists(fact_nr):
                if not pw_data.check(fact_nr, fact_pw):
                    game_email = pw_data.get_email(fact_nr)
                    results = results + [ (fact_nr, game_email, False, fact_pw) ]
                else:
                    game_email = pw_data.get_email(fact_nr)
                    results = results + [ (fact_nr, game_email, True, fact_pw) ]
            else:
                results = results + [ (fact_nr, None, False, fact_pw) ]
    return results

def check_orders(filename, locale, rules):
    options = config.get("game", "checker.parameters", default=None)
    args = [ checker, filename, locale, str(game), gamedir, serverdir]
    if options is not None:
        args.extend(shlex.split(options))
    
    stream = subprocess.Popen(args, stdout=subprocess.PIPE).stdout

    lines = stream.readlines()
    if len(lines)==0:
        stream.close()
        return None
    if len(lines)>maxlines:
        mail = join(lines[:maxlines-3] + ["...", "\n"] + lines[-3:], '')
    else:
        mail = join(lines[:maxlines], '')
    stream.close()
    return mail


# parse the queue file -
#print "connecting to SMTP..."
mailserver = None
if not os.path.exists(muttrc):
    from smtplib import SMTP
    try:
        mailserver = SMTP("localhost")
    except:
        print "could not connect to SMTP server"
        sys.exit(0)

#print "reading password file..."
pw_data = EPasswd(os.path.join(gamedir,"passwd"))

#print "reading orders.queue..."
# move the queue file to a save space while locking it:
try:
    lock_file(queue_file)
except:
    print "could not create lock for %s" %queue_file
    sys.exit(0)
queuefile = open(queue_file, "r")
lines = queuefile.readlines()
queuefile.close()

# copy to a temp file

tname="/tmp/orders.queue.%s" % str(time())
try:
    lock_file(tname)
except:
    print "could not create lock for %s" % tname
    sys.exit(0)
tmpfile=open(tname, "w")
for line in lines:
    tmpfile.write(line)
tmpfile.close()

openlog("orders")

unlink(queue_file)
try:
    unlock_file(queue_file)
except:
    pass

for line in lines:
    tokens = split(line[:-1], ' ')
    dict = {}
    for token in tokens:
        name, value = split(token, '=')
        dict[name] = value

    email = dict["email"]
    locale = dict["locale"]
    game = int(dict["game"])
    infile = dict["file"]
    rules='e%d' % game
    warning = ""
    failed = True
    results = check_pwd(infile, email, pw_data)
    logfile = open(os.path.join(gamedir, "zug.log"), "a")
    dirname, filename = split_filename(infile)
    msg = messages["validate-"+locale] + " " + infile + "\n\n"
    for faction, game_email, success, pwd in results:
        msg = msg + messages["faction-"+locale] + " " + faction + "\n"
        if success: failed = False
        else: msg = msg + messages["unknown-"+locale] + "\n"
        msg = msg + "\n"
        logfile.write("%s:%s:%s:%s:%s:%s\n" % (ctime(time()), email, game_email, faction, pwd, success))
    logfile.close()

    if failed:
        warning = " (" + messages["warning-" + locale] + ")"
        syslog("failed - no valid password in " + infile)
    else:
        result = None
        if os.path.exists(checker):
            result = check_orders(infile, locale, rules)
        if result is None:
            # echeck did not finish
            msg = msg + messages[ "nocheck-" + locale] + "\n"
            warning = " (" + messages["warning-" + locale] + ")"
            syslog("process - checker broken, " + infile)
        else:
            msg = msg + result
            syslog("process - checked orders in " + infile)

    subject = gamename + " " + messages["subject-" + locale] + warning
    try:
        if os.path.exists(muttrc):
            mutt_cmd = "mutt"
            p=subprocess.Popen([ mutt_cmd, "-d2", "-F", muttrc, "-s", subject, "--", email],  stdin=subprocess.PIPE, stdout=subprocess.PIPE)
            sv = p.communicate(msg)
        else:
            msg = "Subject: %s\nFrom: %s\nTo: %s\nContent-Type: text/plain; charset=utf-8\n\n" % (subject, sender, email) + msg
            mailserver.sendmail(sender, email, msg)
    except:
        syslog("failed - cannot send to " + email)

if mailserver is not None:
    mailserver.close()

closelog()
unlink(tname)
unlock_file(tname)
